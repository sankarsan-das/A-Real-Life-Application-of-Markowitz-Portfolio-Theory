# -*- coding: utf-8 -*-
"""Markowitz Portfolio Theory.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/193yPDngvxbkeeQSTvonQSREyJChMKuAR

Firstly, using the **yfinance** library in **Python**, we gather the historical data, i.e. the *close, high, low, open* and *volume* for **Samsung Electronics**, **Apple Inc.**, **Lenovo Group Ltd** and **Dell Inc.** from 15 June 2020 to 25 June 2025 at 00:00 each day.
"""

# Importing and installing the necessary libraries
!pip install yfinance
import yfinance as yf
import pandas as pd


start_date = '2020-06-15' # Setting the starting date
end_date = '2025-06-15' # Setting the ending date


# Storing the historical stock data for Samsung in a Pandas dataframe
ticker_symbol = '005930.KS'
samsung_data = yf.download(ticker_symbol, start=start_date, end=end_date)
samsung_df = pd.DataFrame(samsung_data)


# Doing the same for Apple
ticker_symbol = 'AAPL'
apple_data = yf.download(ticker_symbol, start=start_date, end=end_date)
apple_df = pd.DataFrame(apple_data)


# The Same for Lenovo
ticker_symbol = '0992.HK'
lenovo_data = yf.download(ticker_symbol, start=start_date, end=end_date)
lenovo_df = pd.DataFrame(lenovo_data)


# The same for Dell
ticker_symbol = 'DELL'
dell_data = yf.download(ticker_symbol, start=start_date, end=end_date)
dell_df = pd.DataFrame(dell_data)

"""Now we display the gathered data. (Only the first five entries are being shown in each case.)"""

samsung_data.head()

apple_data.head()

lenovo_data.head()

dell_data.head()

"""For our analysis, we shall use the opening prices of the four stocks. The common dates in each of the four dataframes are identified, and a new dataframe is created consisting of the common dates and the respective opening prices of the four stocks."""

# Finding common dates using the index (which is the date)
common_dates = samsung_df.index.intersection(apple_df.index).intersection(lenovo_df.index).intersection(dell_df.index)


# Filtering the dataframes to keep only the common dates the 'Open' prices (without dropping any levels from the column index)
samsung_common = samsung_df.loc[common_dates].xs('Open', level='Price', axis=1)
apple_common = apple_df.loc[common_dates].xs('Open', level='Price', axis=1)
lenovo_common = lenovo_df.loc[common_dates].xs('Open', level='Price', axis=1)
dell_common = dell_df.loc[common_dates].xs('Open', level='Price', axis=1)


# Creating the new dataframe with common dates and 'Open' prices
common_opens_df = pd.DataFrame({
    'Samsung_Open': samsung_common['005930.KS'],
    'Apple_Open': apple_common['AAPL'],
    'Lenovo_Open': lenovo_common['0992.HK'],
    'Dell_Open': dell_common['DELL']
})


# Display the new dataframe
common_opens_df

"""Now that we have the open prices of each of the four stocks at $T$ distinct times, we may calcuate the rates of return for any particular stock as:
$$r_t=\frac{P_t-P_{t-1}}{P_{t-1}},\ \ \ t=1,2,\dots,T$$
where $P_t$ is the observed open price on the $t$-th point of observation and $r_t$ is the corresponding rate of return. (Note that in this case, $T=1143$.)

"""

# Compute the rate of return for each stock
samsung_returns = (common_opens_df['Samsung_Open'].shift(-1) - common_opens_df['Samsung_Open']) / common_opens_df['Samsung_Open']
apple_returns = (common_opens_df['Apple_Open'].shift(-1) - common_opens_df['Apple_Open']) / common_opens_df['Apple_Open']
lenovo_returns = (common_opens_df['Lenovo_Open'].shift(-1) - common_opens_df['Lenovo_Open']) / common_opens_df['Lenovo_Open']
dell_returns = (common_opens_df['Dell_Open'].shift(-1) - common_opens_df['Dell_Open']) / common_opens_df['Dell_Open']


# Create a new dataframe for the rates of return
returns_df = pd.DataFrame({
    'Samsung_Return': samsung_returns,
    'Apple_Return': apple_returns,
    'Lenovo_Return': lenovo_returns,
    'Dell_Return': dell_returns
})


# Display the returns dataframe
returns_df

"""Having ascertained the historical rates of return for each of the four stocks at the same timestamps, we now proceed to computing the covariance matrix $$\Sigma=\begin{pmatrix}\mathrm{cov}(r_{sam},r_{sam})&\mathrm{cov}(r_{sam},r_{app})&\mathrm{cov}(r_{sam},r_{len})&\mathrm{cov}(r_{sam},r_{dell})\\\mathrm{cov}(r_{app},r_{sam})&\mathrm{cov}(r_{app},r_{app})&\mathrm{cov}(r_{app},r_{len})&\mathrm{cov}(r_{app},r_{dell})\\\mathrm{cov}(r_{len},r_{sam})&\mathrm{cov}(r_{len},r_{app})&\mathrm{cov}(r_{len},r_{len})&\mathrm{cov}(r_{len},r_{dell})\\\mathrm{cov}(r_{dell},r_{sam})&\mathrm{cov}(r_{dell},r_{app})&\mathrm{cov}(r_{dell},r_{len})&\mathrm{cov}(r_{dell},r_{dell})\end{pmatrix}$$ But how does one compute these covariances? For random variables $r_i$ and $r_j$ whose historical data are known to us at $T$ distinct timestamps, we can approximate
$$\mathrm{cov}(r_i,r_j)=\frac{1}{T-1}\sum_{t=1}^T\left(r_{i_t}-\bar{r_i}\right)\left(r_{j_t}-\bar{r_j}\right)$$
where $r_{i_t}$ and $r_{j_t}$ are the observed reurns values of $r_i$ and $r_j$ at timestamp $t$ respectively. Moreover, $\bar{r_i}$ and $\bar{r_j}$ are the means of the historical values of $r_i$ and $r_j$ respectively, i.e.
$$\bar{r_i}=\frac{1}{T}\sum_{t=1}^TR_{i_t},\ \ \ \bar{r_i}=\frac{1}{T}\sum_{t=1}^TR_{j_t}$$

The Pandas library has **cov.()** function that does this.
"""

# Removing the last row as it contains NaN values due to the shift operation
returns_df_cleaned = returns_df.dropna()


# Calculating the covariance matrix using the .cov() function
covariance_matrix_df = returns_df_cleaned.cov()
covariance_matrix = covariance_matrix_df.values


#Displaying the covariance matrix
covariance_matrix

"""Therefore, we have:
$$\Sigma=\begin{pmatrix}0.000315&0.000079&0.000124&0.000157\\0.000079&0.000421&0.000107&0.000231\\0.000124&0.000107&0.000885&0.000221\\0.000157&0.000231&0.000221&0.000979\end{pmatrix}$$

Our next task is to compute $m=\begin{pmatrix}\mathbb{E}[r_{sam}]\\\mathbb{E}[r_{app}]\\\mathbb{E}[r_{len}\\\mathbb{E}[r_{dell}]\end{pmatrix}=\begin{pmatrix}\mu_{sam}\\\mu_{app}\\\mu_{len}\\\mu_{dell}\end{pmatrix}$. For that we will be using the CAPM. Firstly, for each of the four stocks we need an appropariate risk-free rate.

1.   For Samsung (05930.KS), we use the  South Korea 10-Year Government Bond Yield which is around 2.82%.
2.   For Apple (APPL) and Dell (DELL), we use the  US 10-Year Treasury rate which is around 4.30%.
3.   For Lenovo (0992.HK), we use the Hong Kong 10-Year Government Bond Yield which is around 2.98%.

Therefore, $r_{f_{sam}}=0.0282,r_{f_{app}}=r_{f_{dell}}=0.043$ and $r_{f_{len}}=0.0298$.
"""

# Initialising the risk-free rates

r_f_sam = 0.0282
r_f_app = 0.0430
r_f_len = 0.0298
r_f_dell = 0.0430

"""Now to compute $\mu_M$ for each stock, we use **historical average return**. The core principle of this method is as follows:


> This is the most common and straightforward approach. You calculate the average historical returns of a broad market index (like the S&P 500 in the USA, FTSE 100 in the UK, Nifty 50 in India or a global index for a worldwide market) over a long period (e.g. 20, 50 or even 100+ years). If you have historical daily, monthly, or annual returns, you would simply average them. For example, using arithmetic mean: $$\mathbb{E}[r_M]=N_T\cdot\frac{1}{T}\sum_{t=1}^Tr_{M,t}$$ where $r_{M,t}$ is the market return in pertiod $t$ and $T$ is the total number of periods. ($N_T$ is the total number of tr

Now we need to identify the appropriate market index for the primary exchanges of each of the stocks



1.   For Samsung, the primary exchange is KRX, and hence the relevant market index is the KOSPI Composite Index.
2.   For Apple, the primary exchange is NASDAQ, and hence the relevant market index is S&P 500.
3.   For Lenovo, the primary exchange is HKEX, and hence the relevant market index is the Hang Seng Index.
4.   For Apple, the primary exchange is NASDAQ, and hence the relevant market index is S&P 500.


We can now calculate the $\mu_M$ for each of the stocks.
"""

import yfinance as yf
import pandas as pd

# Define time period
start_date = '2020-06-15'
end_date = '2025-06-15'

# Define the tickers for market indices
market_indices = {
    'Samsung': '^KS11',  # KOSPI
    'Apple': '^GSPC',    # S&P 500
    'Lenovo': '^HSI',    # Hang Seng Index
    'Dell': '^GSPC'      # S&P 500 again
}

# Download market index data
kospi_df = yf.download(market_indices['Samsung'], start=start_date, end=end_date)
sp500_df = yf.download(market_indices['Apple'], start=start_date, end=end_date)
hsi_df = yf.download(market_indices['Lenovo'], start=start_date, end=end_date)

# Compute daily returns for each index
kospi_returns = kospi_df['Close'].pct_change().dropna()
sp500_returns = sp500_df['Close'].pct_change().dropna()
hsi_returns = hsi_df['Close'].pct_change().dropna()

# Compute arithmetic mean (i.e., historical average return)
mu_M_samsung = kospi_returns.mean()
mu_M_apple = sp500_returns.mean()
mu_M_lenovo = hsi_returns.mean()
mu_M_dell = sp500_returns.mean()  # same as Apple

# Optional: Annualize the returns (assuming 252 trading days/year)
mu_M_samsung_annual = mu_M_samsung * 252
mu_M_apple_annual = mu_M_apple * 252
mu_M_lenovo_annual = mu_M_lenovo * 252
mu_M_dell_annual = mu_M_dell * 252

# Display the results
print("Daily average market returns (mu_M):")
print(mu_M_samsung)
print(mu_M_apple)
print(mu_M_lenovo)
print(mu_M_dell)

print("\nAnnualized average market returns (mu_M * 252):")
print(mu_M_samsung_annual)
print(mu_M_apple_annual)
print(mu_M_lenovo_annual)
print(mu_M_dell_annual)

"""Therefore, $m=\begin{pmatrix}0.000355\\0.000592\\0.000131\\0.000592\end{pmatrix}$.

Now, using the calculated market returns, we can proceed to compute the beta ($\beta$) for each stock using the following formula:
$$\beta_i = \frac{\mathrm{cov}(r_i, r_M)}{\mathrm{Var}(r_M)}$$
where $r_i$ is the return of the individual stock, $r_M$ is the return of the market index, $\mathrm{cov}(r_i, r_M)$ is the covariance between the stock and market returns, and $\mathrm{Var}(r_M)$ is the variance of the market returns.
"""